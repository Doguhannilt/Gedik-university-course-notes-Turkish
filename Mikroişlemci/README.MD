## Analog ve Sayısal Kavramlar

### Analog ve Sayısal Tekniklerin Genel Özellikleri ve Karşılaştırılması

#### Sayısal ve Analog Sistemler:
- **Dijital Sistemler:** Yalnızca dijital işaretlerle çalışır.
- **Analog Sistemler:** Yalnızca analog işaretlerle çalışır.
- **Karma Sistemler (Hibrit):** Hem dijital hem de analog işaretlerle çalışır.

#### Analog ve Sayısal Tekniklerin Genel Özellikleri ve Karşılaştırılması:
- **Kolay Tasarım:** Sayısal sistemlerin tasarımı daha kolaydır çünkü anahtarlama montajı kullanılır ve akım ile gerilimin kesin değerleri önemli değildir. Önemli olan ‘1’ ve ‘0’ değerleridir.
- **Bilgi Saklama Kolaylığı:** Sayısal sistemlerde bilgilerin saklanması, alınması ve elde tutulması kolaydır.
- **Yüksek Doğruluk ve Bağlanabilirlik:** Sayısal devreler daha yüksek doğruluk sağlar ve daha çok sayıda devrenin birbirine bağlanabilmesine olanak tanır.
- **Programlanabilir İşlemler:** Sayısal sistemlerde işlemler programlanabilir, bu da tasarımı kolaylaştırır. Analog sistemler de programlanabilir ancak esneklik ve komplekslik sınırlıdır.
- **Gürültüye Karşı Dayanıklılık:** Sayısal devreler gürültüden daha az etkilenir. 1 ve 0 olarak kabul edilen gerilim sınırlarını zorlamadığı sürece sinyallerin gürültüden etkilenmesi kritik değildir.
- **Entegre Devreler:** Sayısal devre elemanları entegre devreler içerisine daha fazla yerleştirilebilir. Analog elemanların entegre edilmesi ekonomik değildir.
- **Az Değer ile İşlem:** Sayısal sistemler, sonlu sayıda ayrık değerler üzerinde çalışır. Analog sistemlerde kesintisiz bir süreklilik vardır.
- **Hata Bulma Kolaylığı:** Sayısal sistemlerde kodlama işlemi ile hataların bulunup düzeltilmesi analog sistemlere göre daha kolaydır.


### Tekrarlama ve Çalışma Soruları Cevapları

**1. Büyüklüklerin Genel Özellikleri:**
- **Analog Büyüklükler:** Sürekli değişen ve her an farklı bir değer alabilen büyüklüklerdir. Sonsuz sayıda ara değer alabilirler.
- **Sayısal Büyüklükler:** Belirli ve sonlu sayıda ayrık değerlere sahip olan büyüklüklerdir.

**2. Terimlerin Açıklamaları:**
- **Analog Büyüklük:** Sürekli bir aralıktaki tüm değerleri alabilen fiziksel büyüklüklerdir.
- **Analog İşaret:** Sürekli bir sinyal olan ve zaman içinde sürekli değişim gösteren sinyallerdir. Ölçü ve ayar tekniklerinde kullanılır.
- **Analog Sistem:** Giriş ve çıkışların sürekli sinyaller olduğu sistemlerdir.
- **Analog Gösterge:** Sürekli değişen bir fiziksel büyüklüğü gösteren cihazlardır (örneğin, analog voltmetre).

**3. Analog Sisteme Örnekler:**
- Telefon sistemleri
- Manyetik kasetler
- Termostatlar

**4. Terimlerin Açıklamaları:**
- **Sayısal Büyüklük:** Belirli ve sonlu sayıda ayrık değerlere sahip olan büyüklüklerdir.
- **Sayısal İşaret:** Ayrık zamanlı ve ayrık değerli sinyallerdir.
- **Sayısal Sistem:** Giriş ve çıkışların sayısal sinyaller olduğu sistemlerdir.
- **Sayısal Gösterge:** Sayısal bilgileri gösteren cihazlardır (örneğin, dijital saat).

**5. Sayısal Sisteme Örnekler:**
- Bilgisayar
- Dijital kamera
- Dijital saat

**6. Pozitif ve Negatif Lojik Mantıkları Arasındaki Farklar:**
- **Pozitif Lojik:** '1' mantıksal yüksek seviyeyi (genellikle yüksek voltaj), '0' mantıksal düşük seviyeyi (genellikle düşük voltaj) ifade eder.
- **Negatif Lojik:** '1' mantıksal düşük seviyeyi, '0' mantıksal yüksek seviyeyi ifade eder.

**7. ‘0’ ve ‘1’ Değerlerinin Fiziksel Anlamları:**
- '0' ve '1' genellikle düşük ve yüksek voltaj seviyelerini temsil eder. Örneğin, '0' 0V, '1' 5V olabilir.

**8. Analog veya Sayısal Olarak İsimlendirilen Büyüklükler:**
- **Analog:** Sıcaklık, ses, ışık şiddeti
- **Sayısal:** Bilgisayar verileri, dijital saat zamanı

**9. Sayısal Sistemlerin Alt Grupları:**
- Kombinasyonel lojik devreler
- Ardışıl lojik devreler

**10. Sayısal Sistemlerin Analog Sistemlere Olan Üstünlükleri:**
- Daha kolay tasarım
- Kolay bilgi saklama
- Yüksek doğruluk ve bağlanabilirlik
- Programlanabilir işlemler
- Gürültüye karşı daha dayanıklı
- Daha fazla entegre devre elemanı yerleştirme kapasitesi
- Kodlama işlemi ile hataların bulunup düzeltilmesi kolaylığı

**11. Sayısal Sistemlerin Olumsuzlukları:**
- Sayısal sistemlerin günlük hayatta bazı dezavantajları olabilir (örneğin, bazı analog sinyallerin doğrudan işlenememesi).

**12. Bileşik Lojik Devreleri Tanımı:**
- Giriş sinyalleri ve mevcut durumuna bağlı olarak çıkış veren, ardışık olmayan lojik devrelerdir.

**13. Ardışıl Lojik Terimi:**
- Giriş sinyalleri ve mevcut duruma bağlı olarak belirli bir zaman dizisi içinde çıkış veren lojik devrelerdir.

**14. Bellek Sistemleri Amacı:**
- Verilerin saklanması, depolanması ve gerektiğinde erişilmesi amacıyla kullanılır.

**15. Entegre İçerisinde Oluşturulması Zor Olan Elektronik Devre Elemanları:**
- Yüksek değerli kondansatörler, bobinler, transformatörler

**16. Sayısal Sistemlerde İki Seviyeli Sistem Kullanılma Sebebi:**
- Gürültüye karşı dayanıklılık ve basitlik sağlar.

**17. Sayısal Sistemlerde 10 Farklı Seviyenin Kullanılması Durumunda Oluşabilecek Sakıncalar:**
- Gürültü hassasiyeti artar, tasarım karmaşıklaşır ve güvenilirlik azalır.

**18. Sayısal Sistemlerde İki Seviye Arasında Farklı Seviyeler Kullanılabilir mi:**
- Teorik olarak evet, ancak pratikte zorluklar ve güvenirlik sorunları yaratabilir.

**19. Analog Bilgileri Sayısal Bilgilere Dönüştüren Devreler:**
- Analog-Dijital Çeviriciler (ADC)

**20. Dijital-Analog Çevirici Devre Tanımı:**
- Sayısal veriyi analog sinyale dönüştüren devrelerdir.


## BINARY


1. **İkili (Binary) Sayı Sistemi:** İkili sayı sistemi, yalnızca 0 ve 1 rakamlarını kullanarak sayıları temsil eden bir sayı sistemi olarak tanımlanır. Bilgisayarlar tarafından doğrudan anlaşılabilir ve işlenebilir şekilde veri depolamak ve iletmek için kullanılır.

2. **BIT (Binary Digit):**
   - **BIT:** "Binary Digit" kelimelerinin kısaltmasıdır. İkili sayı sisteminde bir rakamı temsil eder. Yani, 0 veya 1 değerini alabilir.
   - **En Düşük Anlamlı Bit (Least Significant Bit, LSB):** Bir sayıdaki en sağdaki biti ifade eder. Bu bit, sayının en az değişen ve en düşük öneme sahip kısmıdır.
   - **En Yüksek Anlamlı Bit (Most Significant Bit, MSB):** Bir sayıdaki en soldaki biti ifade eder. Bu bit, sayının en fazla değişen ve en yüksek öneme sahip kısmıdır.

3. **Sekizli (Octal) Sayı Sistemi:** Sekizli sayı sistemi, 0'dan 7'ye kadar olan rakamları kullanarak sayıları temsil eder. Bilgisayar sistemlerinde daha az kullanılır ancak bazı durumlarda işlem kolaylığı sağlar.

4. **Sayıların İkili, Sekizli ve Onaltılı Sistemlerde Yazımı:**
   - İkili Sistem: 
     - 0: 0
     - 1: 1
     - ...
     - 20: 10100
   - Sekizli Sistem:
     - 0: 0
     - 1: 1
     - ...
     - 20: 24
   - Onaltılı Sistem:
     - 0: 0
     - 1: 1
     - ...
     - 20: 14

5. **(1471)10 = (?)2 İşlemi:**
   - (1471)10 sayısını ikili (binary) sistemde yazmak için 2'ye bölerek kalıntıları alırız:
     - 1471 ÷ 2 = 735, kalan 1
     - 735 ÷ 2 = 367, kalan 1
     - 367 ÷ 2 = 183, kalan 1
     - 183 ÷ 2 = 91, kalan 1
     - 91 ÷ 2 = 45, kalan 1
     - 45 ÷ 2 = 22, kalan 1
     - 22 ÷ 2 = 11, kalan 0
     - 11 ÷ 2 = 5, kalan 1
     - 5 ÷ 2 = 2, kalan 1
     - 2 ÷ 2 = 1, kalan 0
     - 1 ÷ 2 = 0, kalan 1

     Sonuç olarak, (1471)10 = (10111000111)2

6. **(571,571)10 = (?)2 Dönüşümü:**
    - (571,571)10 sayısını ikili sistemde yazmak için her bir sayıyı ayrı ayrı ikiliye çeviririz:
      - (571)10 = (1000111011)2
      - (571)10 = (1000111011)2

      Sonuç olarak, (571,571)10 = (1000111011,1000111011)2

7. **(346,125)10 = (?)8 İşlemi:**
    - (346)10 sayısını sekizli (octal) sistemde yazmak için 8'e bölerek kalıntıları alırız:
      - 346 ÷ 8 = 43, kalan 2
      - 43 ÷ 8 = 5, kalan 3
      - 5 ÷ 8 = 0, kalan 5

      Sonuç olarak, (346)10 = (525)8

8. **(145,135)10 = (?)16 İşlemi:**
    - (145)10 sayısını onaltılı (hexadecimal) sistemde yazmak için 16'ya bölerek kalıntıları alırız:
      - 145 ÷ 16 = 9, kalan 1
      - 9 ÷ 16 = 0, kalan 9

      (135)10 sayısını onaltılı (hexadecimal) sistemde yazmak için 16'ya bölerek kalıntıları alırız:
      - 135 ÷ 16 = 8, kalan 7
      - 8 ÷ 16 = 0, kalan 8

      Sonuç olarak, (145,135)10 = (91,87)16

9. **(1453,1451)10 = (?)16 İşlemi:**
    - (1453)10 sayısını onaltılı (hexadecimal) sistemde yazmak için 16'ya bölerek kalıntıları alırız:
      - 1453 ÷ 16 = 90, kalan 13 (D)
      - 90 ÷ 16 = 5, kalan 10 (A)
      - 5 ÷ 16 = 0, kalan 5

      (1451)10 sayısını onaltılı (hexadecimal) sistemde yazmak için 16'ya bölerek kalıntıları alırız:
      - 1451 ÷ 16 = 90, kalan 11 (B)
      - 90 ÷ 16 = 5, kalan 10 (A)
      - 5 ÷ 16 = 0, kalan 5

      Sonuç olarak, (1453,1451)10 = (5AD,5AB)16

10. **İkili, Sekizli ve Onaltılı Sistemlerin Tercih Edilme Sebepleri:**
    - **İkili Sistem:** Bilgisayar donanımı için doğrudan uygun olması ve sadece iki değer (0 ve 1) kullanarak veri temsil etmesi nedeniyle tercih edilir.
    - **Sekizli Sistem:** İkili sistemdeki uzun sayıların daha kompakt ve okunabilir bir şekilde temsil edilmesini sağlar.
    - **Onaltılı Sistem:** Uzun sayıların daha kısa bir formda ve daha az rakamla temsil edilmesini sağlar. Ayrıca, renk kodları gibi uygulamalarda kullanımı yaygındır.

11. **(101101011)2 = (?)8 ve (1101101.101101)2 = (?)8 Dönüşümleri:**
    - **(101101011)2 = (?)8:** İkili sistemden sekizli sisteme dönüşüm yaparken gruplara ayırarak her üçlüyü sekizli karşılığına çeviririz.
      - 101 101 011 → 545
      - Sonuç olarak, (101101011)2 = (545)8

    - **(1101101.101101)2 = (?)8:** Ondalık kısımdan sonra da gruplayarak sekizli sistemdeki karşılıklarını buluruz.
      - 110 110 110 → 666
      - 101 101 → 55
      - Sonuç olarak, (1101101.101101)2 = (666.55)8

12. (10111011-10110011)2 işlemini 2 tümleyenine göre yapınız.

Verilen işlem:
```
10111011 (İlk sayı)
- 10110011 (İkinci sayı)
```

1. **Normal Çıkarma İşlemi:**

```
  10111011
- 10110011
-----------
```

2. **İkinci Sayının 2 Tümleyeni (Two's Complement) Alınması:**

İkinci sayının 2 tümleyeni almak için:
- İkinci sayının tüm bitlerini ters çeviririz:
  ```
  10110011 -> 01001100
  ```
- Sonra 1 ekleyerek 2 tümleyeni elde ederiz:
  ```
  01001100 + 1 = 01001101
  ```

İkinci sayının 2 tümleyeni: 01001101

3. **2 Tümleyeni ile Çıkarma İşlemi:**

Şimdi bu 2 tümleyeni, ilk sayıya ekleyerek çıkarma işlemi yapacağız:

```
  10111011 (İlk sayı)
+ 01001101 (İkinci sayının 2 tümleyeni)
-----------
```

4. **Çıkarma İşlemini Yapalım:**

```
  10111011
- 01001101
-----------
```

5. **Sonuç:**

Çıkarma işlemi sonucu:

```
  00001000
```

13. (49262)10 ve (36123)10 sayılarının ‘r-1’tümleyenlerini bulunuz

Evet, 'r-1' tümleyeni bulma işlemi sırasında, sayının bütün bitlerini ters çevirip sonucuna 1 eklemek gerekir. Önce sayının bütün bitlerini ters çevirip, sonra bir ekleyerek 'r-1' tümleyeni elde edilir. Bu işlem, sayının negatif halini temsil etmek için kullanılır.

Şimdi tekrar adım adım 'r-1' tümleyeni bulma işlemine geçelim:

**1. 49262 Sayısının 'r-1' Tümleyeni:**

Verilen sayı: 49262

**Adım 1: Sayının İkili (Binary) Temsilini Bulma**

49262 sayısını ikili sistemde temsil etmek için her adımda 2'ye böleceğiz ve kalanları not edeceğiz:

```
49262 / 2 = 24631, kalan 0
24631 / 2 = 12315, kalan 1
12315 / 2 = 6157, kalan 1
6157 / 2 = 3078, kalan 1
3078 / 2 = 1539, kalan 0
1539 / 2 = 769, kalan 1
769 / 2 = 384, kalan 1
384 / 2 = 192, kalan 0
192 / 2 = 96, kalan 0
96 / 2 = 48, kalan 0
48 / 2 = 24, kalan 0
24 / 2 = 12, kalan 0
12 / 2 = 6, kalan 0
6 / 2 = 3, kalan 0
3 / 2 = 1, kalan 1
1 / 2 = 0, kalan 1
```

Bu adımların sonucunda, 49262 sayısının ikili (binary) temsili:
```
1100000010111110
```

**Adım 2: 'r-1' Tümleyeni Bulma**

Şimdi bu ikili sayının tüm bitlerini ters çevirelim:
```
1100000010111110 -> 0011111101000001
```

Son olarak, bu tümleyenin sonuna 1 ekleyerek 'r-1' tümleyenini elde ederiz:
```
0011111101000001 + 1 = 0011111101000010
```

Dolayısıyla, 49262 sayısının 'r-1' tümleyeni: 0011111101000010 (İkili sistemde)

**2. 36123 Sayısının 'r-1' Tümleyeni:**

Aynı adımları kullanarak 36123 sayısının 'r-1' tümleyenini de bulalım:

**Adım 1: Sayının İkili (Binary) Temsilini Bulma**

36123 sayısını ikili sistemde temsil etmek için her adımda 2'ye böleceğiz ve kalanları not edeceğiz:

```
36123 / 2 = 18061, kalan 1
18061 / 2 = 9030, kalan 1
9030 / 2 = 4515, kalan 0
4515 / 2 = 2257, kalan 1
2257 / 2 = 1128, kalan 1
1128 / 2 = 564, kalan 0
564 / 2 = 282, kalan 0
282 / 2 = 141, kalan 0
141 / 2 = 70, kalan 1
70 / 2 = 35, kalan 0
35 / 2 = 17, kalan 1
17 / 2 = 8, kalan 1
8 / 2 = 4, kalan 0
4 / 2 = 2, kalan 0
2 / 2 = 1, kalan 0
1 / 2 = 0, kalan 1
```

Bu adımların sonucunda, 36123 sayısının ikili (binary) temsili:
```
1000110100011011
```

**Adım 2: 'r-1' Tümleyeni Bulma**

Şimdi bu ikili sayının tüm bitlerini ters çevirelim:
```
1000110100011011 -> 0111001011100100
```

Son olarak, bu tümleyenin sonuna 1 ekleyerek 'r-1' tümleyenini elde ederiz:
```
0111001011100100 + 1 = 0111001011100101
```

Dolayısıyla, 36123 sayısının 'r-1' tümleyeni: 0111001011100101 (İkili sistemde)

**Sonuç:**
- 49262 sayısının 'r-1' tümleyeni: 0011111101000010 (İkili sistemde)
- 36123 sayısının 'r-1' tümleyeni: 0111001011100101 (İkili sistemde)

14. (101110011 – 100111011)2 işlemini ‘r-1’ tümleyeni kullanılarak yapınız.

(101110011 - 100111011)2 işlemini 'r-1' tümleyeni kullanarak yapalım.

**Adım Adım İşlem:**

1. **Verilen İşlem:**

101110011 (İlk sayı)
- 100111011 (İkinci sayı)

2. **İlk Sayının İkili Temsili:**

101110011

3. **İkinci Sayının İkili Temsili ve 'r-1' Tümleyeni Bulma:**

İkinci sayının ikili temsilini bulalım ve 'r-1' tümleyenini elde edelim:

100111011

100111011'in 'r-1' tümleyeni:
```
011000100
```

4. **'r-1' Tümleyeni ile Çıkarma İşlemi:**

Şimdi, 100111011'in 'r-1' tümleyenini 101110011'e ekleyerek çıkarma işlemini yapalım:

```
  101110011 (İlk sayı)
+ 011000100 ('r-1' tümleyeni olarak 100111011'in tersi)
-----------------
  100110111
```

5. **Sonuç:**
sonuç 100110111 olur.

## Coding and Codes

Ezberle:

| Onluk Rakam | BCD Kodu (4 bit) |
|-------------|------------------|
| 0           | 0000             |
| 1           | 0001             |
| 2           | 0010             |
| 3           | 0011             |
| 4           | 0100             |
| 5           | 0101             |
| 6           | 0110             |
| 7           | 0111             |
| 8           | 1000             |
| 9           | 1001             |

BCD (Binary Coded Decimal Code), onluk sistemdeki sayıları ikili sistemde temsil etmek için kullanılan bir kodlama yöntemidir. İkili kodlanmış onlu sayı kodu olarak da bilinir. Bu kodlama yöntemi, her ondalık basamağı dört bitlik ikili gruplar halinde temsil eder.

Örneğin, (263)10 sayısını BCD kodu ile nasıl kodlayacağımızı inceleyelim:

1. İlk olarak, sayının her bir basamağı için onluk sistemdeki değerlerini ikili sistemdeki karşılıklarıyla temsil ederiz.
   - 2 → 0010
   - 6 → 0110
   - 3 → 0011

   Her bir basamak için 4 bitlik ikili gruplar elde edilir.

2. Bu grupları birleştirerek BCD kodlu sayıyı elde ederiz:
   - 2 için 0010
   - 6 için 0110
   - 3 için 0011

   Bu grupları bir araya getirirsek:
   0010 0110 0011

3. Sonuç olarak, (263)10 sayısı BCD koduyla şu şekilde kodlanmış olur:
   (263)10 = (0010 0110 0011)BCD

BCD kodu, özellikle dijital saatlerde, hesap makinelerinde ve diğer uygulamalarda ondalık sayıları doğrudan ikili sistemde temsil etmek için kullanılır. Her bir basamak için sabit bir uzunluk (4 bit) kullanıldığından, hesaplamalar ve işlemler sırasında veri tutarlılığı sağlanmış olur.

### Gray Code

(101110101)2 ikili sistemdeki sayıyı Gray koduna çevirelim.


Gray koduna dönüştürmek için önce her bir bitin değerini sırasıyla alıp, ardışık olarak işlem yapacağız.

Verilen ikili sayı: (101110101)₂

Gray kodu oluşturmak için sırayla her bit ile bir öncekinin XOR (exclusive OR) işlemini yapacağız. İlk bit doğrudan alınır, sonraki bitler ise önceki bit ile XOR işlemi yaparak elde edilir.

İşlem adımları şu şekilde olur:

1. İlk bit doğrudan alınır: 1
2. İlk bit ile ikinci bit arasında XOR işlemi yapılır: 1 XOR 0 = 1
3. 2. bit ile 3. bit arasında XOR işlemi yapılır: 0 XOR 1 = 1
4. 3. bit ile 4. bit arasında XOR işlemi yapılır: 1 XOR 1 = 0
5. 4. bit ile 5. bit arasında XOR işlemi yapılır: 1 XOR 1 = 0
6. 5. bit ile 6. bit arasında XOR işlemi yapılır: 0 XOR 0 = 0
7. 6. bit ile 7. bit arasında XOR işlemi yapılır: 0 XOR 1 = 1
8. 7. bit ile 8. bit arasında XOR işlemi yapılır: 1 XOR 0 = 1
9. 8. bit ile 9. bit arasında XOR işlemi yapılır: 0 XOR 1 = 1

Bu işlemler sonucunda elde edilen Gray kodu: (111100110)₂

Yani, (101110101)₂ ikili sayısı Gray koduna çevrildiğinde (111100110)₂ olarak temsil edilir.

## Çift Eşitlik Tek Eşitlik

Çift eşitlik (even parity) ve tek eşitlik (odd parity) yöntemleri, veri iletiminde hata tespitini sağlamak için kullanılan basit hata kontrolü teknikleridir. Bu yöntemler genellikle tekil bit hatalarını tespit etmek amacıyla kullanılır.

### Tek Eşitlik (Odd Parity) Yöntemi

Tek eşitlik yönteminde, iletilen her veri bloğuna (örneğin, bir byte) ek bir bit eklenir. Bu eklenen bit, veri bloğundaki '1' bitlerinin sayısına bağlı olarak belirlenir. Toplam bit sayısının tek olması gerektiği için, eğer iletilen veri bloğunda '1' bitleri çift sayıdaysa, eklenen bit '1' (tek olmalıdır); eğer '1' bitleri tek sayıdaysa, eklenen bit '0' (çift olmalıdır).

Örneğin, bir byte için tek eşitlik uygulandığında:

- Veri bloğu: 10110010
- '1' bitleri sayısı: 4 (10110010 içinde)
- Tek eşitlik biti (parite biti) hesaplama: '1' (çünkü '1' bitleri sayısı çift)

Bu şekilde, veri bloğu ve eklenen parite biti birlikte iletilir. Alıcı tarafında, gelen veri bloğu ile parite biti kontrol edilir. Eğer veri bloğu ve parite biti arasında uyumsuzluk varsa (örneğin, veri bloğundaki '1' bitleri sayısı değişmişse), hata olduğunu gösterir.

### Çift Eşitlik (Even Parity) Yöntemi

Çift eşitlik yöntemi, tek eşitlik yöntemiyle benzerdir, ancak eklenen parite biti, '1' bitlerinin sayısına göre belirlenirken, '0' bitleri sayısına göre belirlenir. Yani, toplam bit sayısının çift olması gerektiği için, eğer iletilen veri bloğunda '1' bitleri tek sayıdaysa, eklenen bit '1' (tek olmalıdır); eğer '1' bitleri çift sayıdaysa, eklenen bit '0' (çift olmalıdır).

Örneğin, bir byte için çift eşitlik uygulandığında:

- Veri bloğu: 10110010
- '1' bitleri sayısı: 4 (10110010 içinde)
- Çift eşitlik biti (parite biti) hesaplama: '0' (çünkü '1' bitleri sayısı çift)

Bu şekilde, veri bloğu ve eklenen parite biti birlikte iletilir. Alıcı tarafında, gelen veri bloğu ile parite biti kontrol edilir. Eğer veri bloğu ve parite biti arasında uyumsuzluk varsa (örneğin, veri bloğundaki '1' bitleri sayısı değişmişse), hata olduğunu gösterir.

Her iki yöntem de basit ve etkili bir şekilde tekil bit hatalarını tespit etmek için kullanılır, ancak daha karmaşık hata tespit teknikleri (örneğin, CRC - döngüsel düzeltme kodları) daha güçlü ve kapsamlı hata kontrolü sağlar.


### Soru 1: Çift Eşitlik Yöntemi

Verilen sayılar: (1011100) ve (0111000)

#### Adım 2: Çift Eşitlik Yöntemi ile Eşitlik Biti Eklemek

**Veri Bloğu 1: (1011100)**

- '1' bitleri sayısı: 4 (1011100 içinde)
- Çift eşitlik biti (parite biti) hesaplama: '0' (çünkü '1' bitleri sayısı çift)

Bu durumda, (1011100) sayısına çift eşitlik yöntemine göre eklenen eşitlik biti '0' olacaktır.

**Sonuç: (10111000)**

**Veri Bloğu 2: (0111000)**

- '1' bitleri sayısı: 3 (0111000 içinde)
- Çift eşitlik biti (parite biti) hesaplama: '1' (çünkü '1' bitleri sayısı tek)

Bu durumda, (0111000) sayısına çift eşitlik yöntemine göre eklenen eşitlik biti '1' olacaktır.

**Sonuç: (01110001)**

### Soru 19: Tek Eşitlik Yöntemi

Verilen sayılar: (1011100) ve (0111000)

#### Adım 1: Tek Eşitlik Yöntemi ile Eşitlik Biti Eklemek

**Veri Bloğu 1: (1011100)**

- '1' bitleri sayısı: 4 (1011100 içinde)
- Tek eşitlik biti (parite biti) hesaplama: '1' (çünkü '1' bitleri sayısı çift)

Bu durumda, (1011100) sayısına tek eşitlik yöntemine göre eklenen eşitlik biti '1' olacaktır.

**Sonuç: (10111001)**

**Veri Bloğu 2: (0111000)**

- '1' bitleri sayısı: 3 (0111000 içinde)
- Tek eşitlik biti (parite biti) hesaplama: '0' (çünkü '1' bitleri sayısı tek)

Bu durumda, (0111000) sayısına tek eşitlik yöntemine göre eklenen eşitlik biti '0' olacaktır.

**Sonuç: (01110000)**


## Boolean Algebra and Logic Simplification


### 1. Booleron Matematiği Tanıtımı

Boolean matematiği, dijital elektronikte ve bilgisayar biliminde kullanılan matematiksel bir sistemdir. Bu sistem, sadece iki değeri (genellikle 0 ve 1 olarak temsil edilen doğru ve yanlış veya doğru ve yanlış) kullanır. Boolean matematiği, mantıksal işlemler ve ifadeler üzerine kuruludur ve temel amacı doğru/yanlış durumlarını ve bunların kombinasyonlarını matematiksel olarak ifade etmektir.

### 2. Booleron Kuralları

Boolean cebirinde kullanılan temel kurallar şunlardır:

- **De Morgan Kuralları:** (NOT(A AND B) = NOT A OR NOT B) ve (NOT(A OR B) = NOT A AND NOT B) şeklinde ifade edilir. Bu kurallar, NOT, AND ve OR işlemlerini birleştirme ve dönüştürme kurallarıdır.
  
- **Dağılma ve Toplama Kuralları:** Dağılma kuralları, OR işleminin AND üzerinde dağılması (A OR (B AND C) = (A OR B) AND (A OR C)) şeklinde ifade edilir. Toplama kuralları ise AND işleminin OR üzerinde toplanmasıdır ((A AND B) OR (A AND C) = A AND (B OR C)).

- **Kompleman (Ters Alma) Kuralları:** Bir değişkenin ve onun tersinin (komplemanının) toplamı 1'e (veya True) eşittir.

Bu kurallar, lojik ifadeleri sadeleştirmek, analiz etmek ve doğruluğunu değerlendirmek için kullanılır.

### 3. Booleron Kuralarının Sadeleştirme Amacıyla Kullanımı

Boolean kuralları, karmaşık mantıksal ifadeleri daha basit ve anlaşılır bir hale getirmek için kullanılır. Bu süreç, lojik devrelerin tasarımı, analizi ve optimize edilmesi için kritiktir. Örneğin, bir Boolean ifadeyi sadeleştirerek, donanım veya yazılım tasarımında daha az kaynak kullanımı ve daha hızlı işlemler elde edilebilir.

### 4. Doğruluk Tabloları

Doğruluk tabloları, mantıksal ifadelerin tüm giriş kombinasyonlarına göre doğruluğunu gösteren tablolardır. Her bir giriş kombinasyonunda, ifadenin doğru (1) veya yanlış (0) olduğu belirtilir. Bu tablolar, mantıksal ifadelerin analizinde, doğruluğunun değerlendirilmesinde ve sadeleştirilmesinde kullanılır.

### 5. Venn Diyagramı

Venn diyagramı, mantıksal kümelerin ve koşulların görsel temsili için kullanılan bir grafik yöntemdir. Boolean ifadelerin ve mantıksal ilişkilerin görsel olarak temsil edilmesine yardımcı olur. Özellikle kümeler arasındaki kesişim, birleşim ve fark gibi mantıksal ilişkilerin anlaşılmasına katkı sağlar.

### 6. Temel Açılımlar ve Standart İfadeler

Boolean matematiğinde, temel açılımlar ve standart ifadeler, mantıksal ifadeleri sadeleştirmek ve analiz etmek için kullanılan standart formüllerdir. Örneğin, NAND, NOR, XOR gibi temel lojik işlemler ve bunların ifadeleri bu kategoriye girer.

### 7. Çarpımların Toplamı (Mintermlerin Çarpımı)

Çarpımların toplamı, Boolean ifadelerin mintermlerinin (her bir minterm, tüm değişkenlerin belirli bir kombinasyonunu ifade eden ifadelerdir) toplanması işlemidir. Bu işlem, lojik fonksiyonların daha sade ve anlaşılır bir biçimde ifade edilmesini sağlar.

### 8. Minterm ve Maxterm İfadelerinin Birbirlerine Dönüştürülmesi

Minterm ve maxterm ifadeleri, Boolean ifadeleri farklı biçimlerde ifade etmek için kullanılır. Mintermler, AND işlemleriyle bağlı tüm değişkenlerin belirli bir kombinasyonunu ifade ederken, maxtermler, OR işlemleriyle bağlı tüm değişkenlerin belirli bir kombinasyonunu ifade eder. Bu dönüşüm işlemleri, lojik işlemlerin analizinde ve sadeleştirilmesinde kullanılır.

### 9. Lojik İşlemler

Lojik işlemler, temel mantıksal operasyonlardır. Bunlar, AND, OR, NOT gibi işlemlerdir ve Boolean matematiğinde ifadeleri manipüle etmek için kullanılır. Bu işlemler, mantıksal ifadelerin değerlendirilmesi, doğruluğu ve sadeleştirilmesi için temel araçlardır.

## Maxterm | Minterm Detaylı Açıklama

Tabii, minterm ve maxterm kavramlarını daha detaylı bir şekilde açıklayalım.

### Minterm (Minimal Terim)

Minterm, Boolean cebirinde kullanılan bir terimdir ve genellikle "minimal terim" olarak da adlandırılır. Minterm, bir Boolean değişken grubunun tüm değişkenlerinin tam belirli bir kombinasyonunu ifade eden bir ifadedir. Her bir minterm, tüm değişkenlerin belirli bir kombinasyonunu '1' (doğru) ve diğer değişkenlerin '0' (yanlış) olarak ifade eder.

Örneğin, bir değişken kümesi \( A, B, C \) için mintermler şu şekildedir:

- \( A'B'C' \) (000)
- \( A'B'C \) (001)
- \( A'BC' \) (010)
- \( A'BC \) (011)
- \( AB'C' \) (100)
- \( AB'C \) (101)
- \( ABC' \) (110)
- \( ABC \) (111)

Burada her bir minterm, tüm değişkenlerin belirli bir kombinasyonunu içermekte ve tüm değişkenlerin her bir olası durumunu ifade etmektedir. Toplamda \( 2^n \) adet minterm bulunur, burada \( n \) değişken sayısını ifade eder.

### Maxterm (Maximal Terim)

Maxterm, mintermin tam tersidir ve "maksimal terim" olarak da adlandırılır. Bir maxterm, bir Boolean değişken grubunun tüm değişkenlerinin tam belirli bir kombinasyonunu ifade eden bir ifadedir, ancak terimler '0' (yanlış) ve diğer değişkenler '1' (doğru) olarak ifade edilir.

Örneğin, aynı değişken kümesi \( A, B, C \) için maxtermler şu şekildedir:

- \( A+B+C \) (111)
- \( A+B+C' \) (110)
- \( A+B'+C \) (101)
- \( A+B'+C' \) (100)
- \( A'+B+C \) (011)
- \( A'+B+C' \) (010)
- \( A'+B'+C \) (001)
- \( A'+B'+C' \) (000)

Burada her bir maxterm, tüm değişkenlerin belirli bir kombinasyonunu içermekte ve tüm değişkenlerin her bir olası durumunu ifade etmektedir. Toplamda \( 2^n \) adet maxterm bulunur, burada \( n \) değişken sayısını ifade eder.

### Minterm ve Maxterm İfadelerinin Kullanımı

- **Minterm İfadeleri:** Boolean fonksiyonları ifade etmek için kullanılır. Bir Boolean fonksiyonunun mintermleri, her bir fonksiyon değeri için doğrudur (1) veya yanlış (0) olduğunu belirtir.
  
- **Maxterm İfadeleri:** Genellikle fonksiyonların tamamlayıcısı olarak kullanılır. Bir Boolean fonksiyonunun maxtermleri, fonksiyon değerinin tam tersini ifade eder.

### Minterm ve Maxterm İfadelerinin Özellikleri

- **Tamlayıcı İfadeler:** Minterm ve maxterm ifadeleri birbirinin tamlayıcısıdır. Bir fonksiyonun mintermleri ile maxtermleri birleştirildiğinde tüm olası giriş kombinasyonlarını kapsarlar.
  
- **Kullanım Alanları:** Devre tasarımında, doğruluk tablolarının analizinde, fonksiyonların sadeleştirilmesinde (özellikle Karnaugh haritaları kullanılarak) ve lojik devrelerin analizinde minterm ve maxterm ifadeleri sıkça kullanılır.

## Karnaugh Haritaları

Karnaugh haritaları, lojik fonksiyonların sadeleştirilmesi ve analizinde kullanılan grafik bir yöntemdir. Genellikle 2, 3 veya 4 değişkenli fonksiyonlar için kullanılır. İşte bir örnek:

#### 3 Değişkenli Karnaugh Haritası

Karnaugh haritası, değişkenlerin tüm kombinasyonlarını kutular halinde gösterir. Her kutu, bir mintermi temsil eder.

```markdown
| AB\CD | 00 | 01 | 11 | 10 |
|-------|----|----|----|----|
| **00**|    |    |    |    |
| **01**|    |    |    |    |
| **11**|    |    |    |    |
| **10**|    |    |    |    |
```

Bu harita, \( A, B \) ve \( C \) adlı üç değişken için oluşturulmuştur. Her bir hücre, ilgili değişkenlerin kombinasyonunu ifade eder. Örneğin, sol üst köşedeki kutu \( A=0, B=0, C=0 \) kombinasyonunu temsil eder.

#### Örnek Kullanım

Boolean fonksiyonun aşağıdaki gibi olduğunu varsayalım:

```markdown
F(A, B, C) = A'B'C' + A'BC' + AB'C' + ABC
```

Bu fonksiyonun Karnaugh haritası şöyle oluşturulabilir:

```markdown
| AB\CD | 00 | 01 | 11 | 10 |
|-------|----|----|----|----|
| **00**|  1 |  1 |  0 |  1 |
| **01**|  0 |  0 |  0 |  1 |
| **11**|  0 |  1 |  1 |  0 |
| **10**|  1 |  0 |  0 |  0 |
```

Bu haritada, her kutu mintermi temsil eder. '1' değeri, o mintermin bu kombinasyon için doğru olduğunu gösterir. Örneğin, sol üst köşedeki kutu \( A'BC' \) mintermini temsil eder.

#### Kullanım Adımları

1. **Fonksiyonun Mintermlerini Belirleme:** Boolean fonksiyonunuzu mintermlerine ayırın.
   
2. **Karnaugh Haritasını Oluşturma:** Değişkenlerin tüm kombinasyonlarını içeren bir tablo oluşturun.

3. **Mintermleri Haritaya Yerleştirme:** Her mintermi, ilgili kutuya yerleştirin. Minterm '1' ise, kutuya '1' yazın.

4. **Gruplama Yapma:** Haritadaki '1' değerlerini gruplayarak, sadeleştirilmiş ifadeyi oluşturun. Gruplar, komşu kutular arasında olmalı ve 2^n sayıda hücre içermelidir.


